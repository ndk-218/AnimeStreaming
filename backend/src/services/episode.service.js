// @ts-nocheck
const Episode = require('../models/Episode');
const Season = require('../models/Season');
const Series = require('../models/Series');
const path = require('path');
const fs = require('fs-extra');

/**
 * ===== EPISODE SERVICE - JAVASCRIPT VERSION =====
 * T·∫≠p trung Phase 1: Admin upload, Anonymous streaming
 */
class EpisodeService {
  
  /**
   * T·∫°o episode m·ªõi v√† chu·∫©n b·ªã x·ª≠ l√Ω video
   */
  static async createEpisode(data) {
    try {
      // Validate d·ªØ li·ªáu ƒë·∫ßu v√†o
      if (!data.seriesId || !data.seasonId || !data.episodeNumber || !data.title) {
        throw new Error('Missing required fields: seriesId, seasonId, episodeNumber, title');
      }

      // Ki·ªÉm tra season t·ªìn t·∫°i
      const season = await Season.findById(data.seasonId);
      if (!season) {
        throw new Error('Season not found');
      }

      // Ki·ªÉm tra series t·ªìn t·∫°i
      const series = await Series.findById(data.seriesId);
      if (!series) {
        throw new Error('Series not found');
      }

      // Ki·ªÉm tra episode number ƒë√£ t·ªìn t·∫°i ch∆∞a
      const existingEpisode = await Episode.findOne({
        seasonId: data.seasonId,
        episodeNumber: data.episodeNumber
      });

      if (existingEpisode) {
        throw new Error(`Episode ${data.episodeNumber} already exists in this season`);
      }

      // T·∫°o episode m·ªõi
      const episode = await Episode.create({
        seriesId: data.seriesId,
        seasonId: data.seasonId,
        episodeNumber: data.episodeNumber,
        title: data.title,
        description: data.description || '',
        originalFile: data.originalFile,
        processingStatus: 'pending'
      });

      console.log(`‚úÖ Episode created: ${episode.title} (ID: ${episode._id})`);
      return episode;

    } catch (error) {
      console.error('‚ùå Error creating episode:', error.message);
      throw error;
    }
  }

  /**
   * L·∫•y episode v·ªõi th√¥ng tin chi ti·∫øt
   */
  static async getEpisodeWithDetails(episodeId) {
    try {
      const episode = await Episode.findById(episodeId)
        .populate('seriesId', 'title slug posterImage')
        .populate('seasonId', 'title seasonNumber seasonType');
        
      return episode;
    } catch (error) {
      console.error('‚ùå Error getting episode details:', error.message);
      throw error;
    }
  }

  /**
   * L·∫•y t·∫•t c·∫£ episodes trong m·ªôt season
   */
  static async getEpisodesBySeason(seasonId, onlyCompleted = false) {
    try {
      const query = { seasonId };
      
      if (onlyCompleted) {
        query.processingStatus = 'completed';
      }

      const episodes = await Episode.find(query)
        .select('episodeNumber title description duration thumbnail hlsPath processingStatus viewCount')
        .sort({ episodeNumber: 1 });

      return episodes;
    } catch (error) {
      console.error('‚ùå Error getting episodes by season:', error.message);
      throw error;
    }
  }

  /**
   * C·∫≠p nh·∫≠t tr·∫°ng th√°i x·ª≠ l√Ω video
   */
  static async updateProcessingStatus(episodeId, updates) {
    try {
      const episode = await Episode.findById(episodeId);
      if (!episode) {
        throw new Error('Episode not found');
      }

      // C·∫≠p nh·∫≠t c√°c tr∆∞·ªùng ƒë∆∞·ª£c ph√©p
      const allowedFields = [
        'processingStatus', 
        'hlsPath', 
        'qualities', 
        'duration', 
        'thumbnail',
        'subtitles'
      ];

      allowedFields.forEach(field => {
        if (updates[field] !== undefined) {
          episode[field] = updates[field];
        }
      });

      await episode.save();
      
      console.log(`üì∫ Episode processing updated: ${episode.title} - Status: ${episode.processingStatus}`);
      return episode;

    } catch (error) {
      console.error('‚ùå Error updating processing status:', error.message);
      throw error;
    }
  }

  /**
   * L·∫•y episode ti·∫øp theo trong season
   */
  static async getNextEpisode(currentEpisodeId) {
    try {
      const currentEpisode = await Episode.findById(currentEpisodeId);
      if (!currentEpisode) return null;

      const nextEpisode = await Episode.findOne({
        seasonId: currentEpisode.seasonId,
        episodeNumber: { $gt: currentEpisode.episodeNumber },
        processingStatus: 'completed'
      })
      .select('episodeNumber title')
      .sort({ episodeNumber: 1 });

      return nextEpisode;
    } catch (error) {
      console.error('‚ùå Error getting next episode:', error.message);
      return null;
    }
  }

  /**
   * L·∫•y episode tr∆∞·ªõc ƒë√≥ trong season
   */
  static async getPreviousEpisode(currentEpisodeId) {
    try {
      const currentEpisode = await Episode.findById(currentEpisodeId);
      if (!currentEpisode) return null;

      const previousEpisode = await Episode.findOne({
        seasonId: currentEpisode.seasonId,
        episodeNumber: { $lt: currentEpisode.episodeNumber },
        processingStatus: 'completed'
      })
      .select('episodeNumber title')
      .sort({ episodeNumber: -1 });

      return previousEpisode;
    } catch (error) {
      console.error('‚ùå Error getting previous episode:', error.message);
      return null;
    }
  }

  /**
   * TƒÉng view count cho episode
   */
  static async incrementViewCount(episodeId) {
    try {
      const episode = await Episode.findByIdAndUpdate(
        episodeId,
        { $inc: { viewCount: 1 } },
        { new: true }
      );

      return episode;
    } catch (error) {
      console.error('‚ùå Error incrementing view count:', error.message);
      throw error;
    }
  }

  /**
   * Th√™m subtitle cho episode
   */
  static async addSubtitle(episodeId, subtitleData) {
    try {
      const episode = await Episode.findById(episodeId);
      if (!episode) {
        throw new Error('Episode not found');
      }

      // Ki·ªÉm tra subtitle ƒë√£ t·ªìn t·∫°i ch∆∞a
      const existingSubtitle = episode.subtitles.find(
        sub => sub.language === subtitleData.language && sub.type === subtitleData.type
      );

      if (existingSubtitle) {
        // C·∫≠p nh·∫≠t subtitle hi·ªán c√≥
        existingSubtitle.label = subtitleData.label;
        existingSubtitle.file = subtitleData.file;
      } else {
        // Th√™m subtitle m·ªõi
        episode.subtitles.push(subtitleData);
      }

      await episode.save();
      console.log(`üìù Subtitle added: ${subtitleData.language} for episode ${episode.title}`);
      
      return episode;
    } catch (error) {
      console.error('‚ùå Error adding subtitle:', error.message);
      throw error;
    }
  }

  /**
   * X√≥a episode (ch·ªâ admin)
   */
  static async deleteEpisode(episodeId) {
    try {
      const episode = await Episode.findById(episodeId);
      if (!episode) {
        return false;
      }

      // X√≥a files video n·∫øu c√≥
      if (episode.hlsPath) {
        const videoDir = path.dirname(episode.hlsPath);
        try {
          await fs.remove(videoDir);
          console.log(`üóëÔ∏è Removed video files: ${videoDir}`);
        } catch (fileError) {
          console.error('‚ö†Ô∏è Could not remove video files:', fileError.message);
        }
      }

      // X√≥a episode kh·ªèi database
      await Episode.findByIdAndDelete(episodeId);
      
      console.log(`‚úÖ Episode deleted: ${episode.title}`);
      return true;
      
    } catch (error) {
      console.error('‚ùå Error deleting episode:', error.message);
      throw error;
    }
  }

  /**
   * T√¨m ki·∫øm episodes theo title
   */
  static async searchEpisodes(searchTerm, limit = 20) {
    try {
      const episodes = await Episode.find({
        title: { $regex: searchTerm, $options: 'i' },
        processingStatus: 'completed'
      })
      .populate('seriesId', 'title slug posterImage')
      .populate('seasonId', 'title seasonNumber')
      .select('episodeNumber title description thumbnail viewCount')
      .sort({ viewCount: -1 })
      .limit(limit);

      return episodes;
    } catch (error) {
      console.error('‚ùå Error searching episodes:', error.message);
      throw error;
    }
  }

  /**
   * L·∫•y episodes ph·ªï bi·∫øn nh·∫•t
   */
  static async getPopularEpisodes(limit = 10) {
    try {
      const episodes = await Episode.find({
        processingStatus: 'completed'
      })
      .populate('seriesId', 'title slug posterImage genres')
      .populate('seasonId', 'title seasonNumber')
      .select('episodeNumber title description thumbnail viewCount')
      .sort({ viewCount: -1 })
      .limit(limit);

      return episodes;
    } catch (error) {
      console.error('‚ùå Error getting popular episodes:', error.message);
      throw error;
    }
  }

  /**
   * Ki·ªÉm tra episode c√≥ th·ªÉ ph√°t ƒë∆∞·ª£c kh√¥ng
   */
  static isEpisodePlayable(episode) {
    return episode.processingStatus === 'completed' && 
           episode.hlsPath && 
           episode.qualities && 
           episode.qualities.length > 0;
  }

  /**
   * L·∫•y th·ªëng k√™ episodes
   */
  static async getEpisodeStats() {
    try {
      const stats = await Episode.aggregate([
        {
          $group: {
            _id: '$processingStatus',
            count: { $sum: 1 }
          }
        }
      ]);

      const totalEpisodes = await Episode.countDocuments();
      const totalViews = await Episode.aggregate([
        { $group: { _id: null, totalViews: { $sum: '$viewCount' } } }
      ]);

      return {
        total: totalEpisodes,
        byStatus: stats.reduce((acc, item) => {
          acc[item._id] = item.count;
          return acc;
        }, {}),
        totalViews: totalViews[0]?.totalViews || 0
      };

    } catch (error) {
      console.error('‚ùå Error getting episode stats:', error.message);
      throw error;
    }
  }
}

module.exports = EpisodeService;